# 变量和基本类型

## 内置基本类型

基本数据类型包括**算数类型** arithmetic(字符整型布尔浮点)和**空类型**void

算数类型：整型（布尔、字符）、浮点

----

### 算数类型

#### 符号和无符号类型

无符号类型只能表示大于等于0的数，在类型名前加unsigned 可以得到无符号类型

字符型分为`char`、`signed char`和`unsigned char`三种，但是表现形式只有带符号和无符号两种。类型`char`和`signed char`并不一样， `char`的具体形式由编译器（compiler）决定

数据类型选择：明确知道数据不为负数，选择无符号类型；使用int执行整数运算，超过int选择long long；算数表达式中避免使用bool和char；执行浮点选择double

#### 类型转换

类型所能表示的值决定了转换的过程：
赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。

负数--》无符号数：负数加上无符号数的模

布尔--》非布尔：false: 0; true : 1   非布尔 --》布尔：0：false； else： true

浮点--》整数：仅仅保留整数部分

整数--》浮点：小数部分记为0； 超过浮点容量就会有精度损失

表达式中含有无符号数，会将int转换为无符号数，无符号数不会小于0，for循环降序注意死循环

#### 字面值常量

字面值常量的值和形式决定了数据类型

以`0`开头的整数代表八进制（octal）数，以`0x`或`0X`开头的整数代表十六进制（hexadecimal）数。在C++14中，`0b`或`0B`开头的整数代表二进制（binary）数。

浮点数默认字面值是double， ‘x’:字符字面值  “hi” 字符串字面值

字符串字面值可以分多行书写，每行“”回车“”  \\n转义序列

指定字面值的类型 3.14L \\\\ long double  u8"dasd"utf -8  u unicode16  U unicode32   88LL longlong 5u unsign

true,false bool字面值， nullptr 是指针字面值

### 变量

具名可供程序操作的存储空间，数据类型决定变量所占内存大小和布局方式

----

#### 变量定义

类型说明符号  一个或多个（声明符）变量名组成的列表；

初始值：创建变量的时候赋予的初始值，不同于赋值：擦除当前值，以一个新的值来代替

列表初始化：int a = 0; int a = {0}; int a{0}; 使用列表初始化存在信息丢失的风险时，编译器会报错

默认初始值：定义于任何函数体之外的内置类型变量被初始化为0；定义在函数体内部的内置类型不能被初始化

声明：extern int i; 声明i而不是定义i   int i 声明并定义i  extern double pi = 3.12  声明并定义i

声明规定标量的类型和名字，使得变量名字为程序所知道，定义负责创建与2名字关联的实体

变量只能被定义一次，但是可以声明多

标识符：变量名一般小写，类名大写开头，字母下划线开头，用户自定义标识符不能出现连续两个下划线，不能下划线紧连大写字母，不能关键字和操作符替代名

作用域：始声明语句，以声明语句作用域末端为结束

定义main函数外面的标量有全局作用域，允许在内层作用域中重新定义外层作用域已有的名字，::name显示访问全局作用域的同名变量

#### 复合类型

基于其他类型定义的类型:指针引用

引用：将声明符号写成 &变量名，定义时，把引用和初始值绑定在一起，无法重新绑定到另一个对象

引用不是对象，是为已有的对象起的别名，为引用赋值，其实是为所引用的对象赋值，获取引用的值，是获取所引用的对象的值，定义时必须初始化

引用只能绑定在对象上，不能绑定在字面值上，引用类型必须和绑定的对象类型严格匹配

指针：本身是一个对象，无须再定义赋值，在块内作用域定义未初始化就会拥有不确定的值

指针定义：将声明符号写成 *变量名 int *p = &y; &取地址符，指针类型需要和做指类型严格匹配（声明的指针类型名被用于定义指定所指向的对象的类型）

指针的值的四种状态：指向对象；指向紧邻对象的下一个位置；空指针没有指向；无效指针else（访问会引发错误）

*解引用符访问所指向的对象 *p：只适用于确实指向了对象的有效指针

空指针：使用字面值nullptr初始化指针 0 NULL

指针本身是一个对象，可以修改值使得指向不同的对象

有合法值的指针可以用在条件表达式中，非0指针的条件值都是true

void\*指针：特殊指针，可以用于存放任意对象的i地址，不能操作void\*所指的对象（不知道类型），仅仅只是内存空间，没办法访问内存空间所存的对象

\* & 是声明符的一部分，定义多个变量时候，注意只能作用于修饰最近的那个变量名

指向指针的指针，指向指针的引用，不存在引用的引用

#### const限定符

使用const对变量的类型加以限定，值不能改变，防止程序不小心修改了值

const值一旦创建了就不能再改变，所以const对象必须初始化，可以用变量初始化

const的常量特性仅仅在试图改变知道额操作时候才会发挥作用，其余和普通一样：赋值，转换bool等等

const在默认状况下，仅仅在当前文件内有效

const的引用：对常量的应用，不能修改所绑定的对象的值

# 2 字符串向量和数组

----

## 2.1 命名空间的using声明

`std::cin` :使用命名空间std中的cin；`::a`: 使用全局作用域中的a

using声明： using namespace::name; 声明后，可以直接使用name，每个名字需要独立的using声明语句

头文件中不应当包含using声明

## 2.2 标准库类型String

表示可边长的字符序列：#include\<string> using std::string

### 定义和初始化string对象

```
string s1;                       //默认初始化，空字符串
string s2 = s1; string s2(s1)    //s2是s1的副本，=是拷贝初始化，（）直接初始化
string s3 = "hi"; string s3("hi")//字面值的拷贝构造和直接初始化，除了字面值最后的空字符'\0'
string s4(10, 'c')               //初始化为连续n个字符c组成的串

string s8 = string(10, 'a')      //基于临时对象的拷贝初始化
```

### string对象上的操作

#### 读写string对象

string s; cin >> s; cout << s << endl;

执行读取操作时，会自动忽略开头的空白（空格换行制表等），遇到空白停止，键入“hi world” 实际值 “hi”

string的  << >> 返回左侧的运算对象作为结果，所以可以连续读写cin >> s1 >> s2;

getline(cin，s); 从输入流中读取内容（保留空白符），直到遇到换行符为止，得到的string对象中不包含换行符

#### empty size

empty函数返回对象是否为空的布尔值；size函数返回string对象的长度

string::size_type: size函数的返回值，是无符号类型，s.size() <n 当n为负数时总为true，因为负数自动转换为很大的无符号数

`	decltype(s.size()) aa; auto ab = s.size();`

#### 比较

== != 检查俩个字符串对象相等与否：长度相等且所包含的字符也全部相等

\> >= < <=: 1.长度不同且短的是长的前缀，则短小于长；2.第一对不同的字符的大小写敏感的字典排序a97A65

#### 赋值

允许把一个对象的值赋给另一个对象 s1 = s2;

#### 相加

两个string对象相加 `s += s1`等价于`s = s + s1`；使用加法的结果是一个新的字符串

字面值和字符串相加：+两侧的对象至少有一个是string，不能把字面值直接相加；也支+= 符合赋值运算符运算

s1 = "a" +  "a" 错误  s2 = ("a" + s2) + "1"正确

### string对象中的字符

cctype头文件是C语言中ctype.h头文件内容相同，cctype从命名更符合C++要求

isalnum 、isalpha、isdigit、islower、ispunct、isspace(各种空白符)、issupper、tolower、toupper

#### 使用基于范围的for

```
for (auto c : s) {}  for （auto& c : s）{定义循环变量为引用，改变内容}
```

#### 使用下标

[] ：下标运算符，接受参数是string::size_type；必须检查下标值的合法性

```C++
//第一个单词改为大写	
for (decltype(s.size()) i = 0; i != s.size() && ! isspace(s[i]); ++i) {
		s[i] = toupper(s[i]);
}
// c的类型是const char& ,如果不改变c就盒饭，改变就不合法
const string s = "sss";
for (auto& c : s) {
}
```

## 2.3 vector

标准库类型vector表示对象的集合，其中所有的**对象**的类型都相同，集合中的每个对象都有与之对应的索引，是类模板，编译器根据模板船舰类或者函数的过程称为实例化，使用模板时候，需要指出编译器应该把类或者函数实例化为何种类型

### 2.3.1 定义和初始化对象

`vector<string> svec` 默认初始化，不含有任何元素

`vector<int> vint(vint2);  vector<int> vint = vint2`  拷贝初始化，v2包含所有v1元素的副本

`vector<int> bv1{1,2,3}  vector<int> bv1 = {1,2,3}` 初始化列表初始化

`vector<int> a(10,0)` 初始化为指定数量的元素，capacity == size = 10

`vector<int> a(10)`  值初始化：只提供元素数量，库会创建值初始化的元素初值，并赋予容器所有元素

当使用{}进行初始化时，当提供的值不能执行列表初始化的时候，编译器会尝试使用默认初始化

`vector<string> v1{10}` 10个默认初始化的元素的容器 `vector<int>{'s'} ` 初始化列表初始化，值为115

### 2.3.2 vector操作

push_back,：把一个值当作vector对象压入容器尾部

在范围for循环中不应该改变其所遍历的序列的大小

.size() .capacity() .empty()    vector<\int> :: size_type 

[] 索引的下标类型是size_type类型，使用下标运算需要检查下标合法性，所以不能以下标形式添加函数，只能对已存在的元素进行下标操作

== 两个vevtor相等当且仅当元素个数相同且对应元素的值也相同，> <比较与string相同

## 2.4 迭代器

类似于指针类型，提供对对象的间接访问，有效迭代器：指向元素或者指向元素的下一个位置

获取迭代器使用迭代器成员函数返回

`auto b = v.begin()` `auto c = v.end()` 当容器为空时候返回的是同一个迭代器

### 2.4.1 迭代器运算

`*iter` 返回迭代器所指向的元素 iter->men 解引用并获取成员，等价于（*iter）.mem 必须括号

++iter 另迭代器指示下一个元素--iter iter1 ==iter2 iter1 != iter2 指示同一个元素或者同一个容器的尾后迭代器，则相等

end返回的迭代器并不指示任何元素，所以不能对其递增或者接引用

迭代一个容器的时候，判断容器迭代完成条件是 iter != s.end() ,因为所有的标准库类型都定义了== ！= ，但不一定定义了 > <

迭代器类型 vector\<int>::iterator it  vector\<int>::const_iterator it 两种， 后一种类似于常量指针只能读，如果容器类是常量，则只能使用后一种迭代器

const vector\<int> a; a.begin() 返回const_iterator

cbegin() cend() 始终返回const iterator

任何改变容器容量的操作，都会使得迭代器失效



 iter + n iter-n  iter +-= n  iter1-iter2 >< >= <= == 迭代器相减是他们的距离，必须是指示的两个同一容器的元素或者下一位置

迭代器之差是带符号的difference_type类型，二分法中的迭代器 mid = beg + (end - bed) /2







## 2.5 C 风格字符串

c风格字符串不是一种类型，而是为了表达和使用字符的一种写法，字符串放在字符数组中，并以'\0'结束，一般以指针操作字符，定义在cstring中

strlen\() strcmp()比较相等性，大于返回正 strcat(p1,p2) p2附加到p1后面，返回p1 strcpy(p1,p2)  p2拷贝给p1返回p1   c风格字符串不负责检查字符串参数

`char ca[] = {'a','b'} ，strlen(ca)`错误strlen 不以空字符结束报错，strlen会沿着ca在内存中的位置找到空才会停止

c风格字符串的比较实际上是比较指针而不是字符本身 ca > cb结果是未定义的

cf风格字符串的相加（指针相加）也是未定义的，必须使用函数

尽量不适用c风格字符串

```
	const char ca[] = { 'h', 'e', 'l', 'l', 'o' };
	const char s[] = "world";
	const char* cp = ca;
	while (*cp) {
		cout << *cp;
		++cp;
	}
	// .rodata 中h e l l o w o r l d \0 会输出
	// const char ca[] = { 'h', 'e', 'l', 'l', 'o' ，‘\0’};才会输出hello
```

定义两个字符数组并用字面值（带空白符）初始化；再用字面值存放连接后的

```
    const char cstr1[] = "Hello";
    const char cstr2[] = "world!";

    size_t new_size = strlen(cstr1) + strlen(" ") + strlen(cstr2) + 1;
    char* cstr3 = new char[new_size];

    strcpy(cstr3, cstr1);
    strcat(cstr3, " ");
    strcat(cstr3, cstr2);

    std::cout << cstr3 << std::endl;
    delete [] cstr3;
```



## 3. 表达式

### 3.1 基础

一元运算符
